{"version":3,"sources":["../src/ajvErrorNormalizer.ts"],"names":[],"mappings":"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","sourcesContent":["import { AdditionalPropertiesParams, ComparisonParams, DependenciesParams, ErrorObject, TypeParams } from \"ajv\"\n\nexport function normaliseErrorMessages(errors: Array<ErrorObject>, schemeData: object) {\n  const printer = new SchemeErrorPrinter(schemeData)\n  return \"Configuration is invalid.\\n\" +\n    filterErrors(errors)\n      .map(it => \" - \" + indent(printer.formatValidationError(it), \"   \", false))\n      .join(\"\\n\")\n}\n\n//tslint:disable-next-line:no-empty-interface\ninterface Scheme {\n  // to ensure that proper arg is passed\n}\n\nclass SchemeErrorPrinter {\n  constructor(readonly schemeData: Scheme) {\n  }\n\n  formatValidationError(error: ErrorObject) {\n    const dataPath = `configuration${error.dataPath}`\n    if (error.keyword === \"additionalProperties\") {\n      return `${dataPath} has an unknown property '${(error.params as AdditionalPropertiesParams).additionalProperty}'. These properties are valid:\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n    else if (error.keyword === \"oneOf\" || error.keyword === \"anyOf\") {\n      const children = (error as any).children\n      if (children && children.length > 0) {\n        // use set to remove duplicated messages like \"should be an object.\"\n        return `${dataPath} should be one of these:\\n${this.getSchemaPartText(error.parentSchema)}\\n` +\n          `Details:\\n${Array.from(new Set(children.map((it: ErrorObject) => \" * \" + indent(this.formatValidationError(it), \"   \", false)))).join(\"\\n\")}`\n      }\n      return `${dataPath} should be one of these:\\n${this.getSchemaPartText(error.parentSchema)}`\n\n    }\n    else if (error.keyword === \"enum\") {\n      if (error.parentSchema && (error.parentSchema as any).enum && (error.parentSchema as any).enum.length === 1) {\n        return `${dataPath} should be ${this.getSchemaPartText(error.parentSchema)}`\n      }\n      return `${dataPath} should be one of these:\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n    else if (error.keyword === \"allOf\") {\n      return `${dataPath} should be:\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n    else if (error.keyword === \"type\") {\n      switch ((error.params as TypeParams).type) {\n        case \"object\":\n          return `${dataPath} should be an object.`\n        case \"string\":\n          return `${dataPath} should be a string.`\n        case \"boolean\":\n          return `${dataPath} should be a boolean.`\n        case \"number\":\n          return `${dataPath} should be a number.`\n        case \"array\":\n          return `${dataPath} should be an array:\\n${this.getSchemaPartText(error.parentSchema)}`\n      }\n      return `${dataPath} should be ${(error.params as TypeParams).type}:\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n    else if (error.keyword === \"instanceof\") {\n      return `${dataPath} should be an instance of ${this.getSchemaPartText(error.parentSchema)}.`\n    }\n    else if (error.keyword === \"required\") {\n      const missingProperty = (error.params as DependenciesParams).missingProperty.replace(/^\\./, \"\")\n      return `${dataPath} misses the property '${missingProperty}'.\\n${this.getSchemaPartText(error.parentSchema, [\"properties\", missingProperty])}`\n    }\n    else if (error.keyword === \"minLength\" || error.keyword === \"minItems\") {\n      if ((error.params as ComparisonParams).limit === 1) {\n        return `${dataPath} should not be empty.`\n      }\n      else {\n        return `${dataPath} ${error.message}`\n      }\n    }\n    else if (error.keyword === \"absolutePath\") {\n      const baseMessage = `${dataPath}: ${error.message}`\n      if (dataPath === \"configuration.output.filename\") {\n        return `${baseMessage}\\n` +\n          \"Please use output.path to specify absolute path and output.filename for the file name.\"\n      }\n      return baseMessage\n    }\n    else {\n      // eslint-disable-line no-fallthrough\n      return `${dataPath} ${error.message} (${JSON.stringify(error, null, 2)}).\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n  }\n\n  private getSchemaPart(path: string) {\n    const pathList = path.split(\"/\").slice(0, path.length)\n    let schemaPart = this.schemeData as any\n    for (let i = 1; i < pathList.length; i++) {\n      const inner = schemaPart[pathList[i]]\n      if (inner) {\n        schemaPart = inner\n      }\n    }\n    return schemaPart\n  }\n\n  private getSchemaPartText(schemaPart: any, additionalPath: Array<string> | null = null) {\n    if (additionalPath != null) {\n      for (const p of additionalPath) {\n        const inner = schemaPart[p]\n        if (inner) {\n          schemaPart = inner\n        }\n      }\n    }\n\n    while (schemaPart.$ref != null) {\n      schemaPart = this.getSchemaPart(schemaPart.$ref)\n    }\n\n    let schemaText = this.formatSchema(schemaPart)\n    let description = schemaPart.description\n    if (description != null) {\n      description = description.trim()\n      const twoLineBreakPosition = description.indexOf(\"\\n\\n\")\n      description = twoLineBreakPosition < 0 ? description : description.substring(0, twoLineBreakPosition)\n      schemaText += `\\n${description}\\n`\n    }\n    return schemaText\n  }\n\n  private formatSchema(schema: any, prevSchemas?: any) {\n    prevSchemas = prevSchemas || []\n\n    const formatInnerSchema = (innerSchema: any, isAddSelf = false): string => {\n      if (!isAddSelf) {\n        return this.formatSchema(innerSchema, prevSchemas)\n      }\n      if (prevSchemas.indexOf(innerSchema) >= 0) {\n        return \"(recursive)\"\n      }\n      return this.formatSchema(innerSchema, prevSchemas.concat(schema))\n    }\n\n    if (schema.type === \"string\") {\n      if (schema.minLength === 1) {\n        return \"non-empty string\"\n      }\n      else if (schema.minLength > 1) {\n        return `string (min length ${schema.minLength})`\n      }\n      else {\n        return \"string\"\n      }\n    }\n    else if (schema.type === \"boolean\") {\n      return \"boolean\"\n    }\n    else if (schema.type === \"number\") {\n      return \"number\"\n    }\n    else if (schema.type === \"object\") {\n      if (schema.properties) {\n        const required = schema.required || []\n        return `object { ${Object.keys(schema.properties).map(property => {\n          if (required.indexOf(property) < 0) {\n            return property + \"?\"\n          }\n          return property\n        }).concat(schema.additionalProperties ? [\"...\"] : []).join(\", \")} }`\n      }\n      if (schema.additionalProperties) {\n        return `object { <key>: ${formatInnerSchema(schema.additionalProperties)} }`\n      }\n      return \"object\"\n    }\n    else if (schema.type === \"array\") {\n      return `[${formatInnerSchema(schema.items)}]`\n    }\n\n    switch (schema.instanceof) {\n      case \"Function\":\n        return \"function\"\n      case \"RegExp\":\n        return \"RegExp\"\n    }\n\n    if (schema.$ref != null) {\n      return formatInnerSchema(this.getSchemaPart(schema.$ref), true)\n    }\n    if (schema.allOf) {\n      return schema.allOf.map(formatInnerSchema).join(\" & \")\n    }\n    if (schema.oneOf) {\n      return schema.oneOf.map(formatInnerSchema).join(\" | \")\n    }\n    if (schema.anyOf) {\n      return schema.anyOf.map(formatInnerSchema).join(\" | \")\n    }\n    if (schema.enum) {\n      return schema.enum.map((it: object) => JSON.stringify(it)).join(\" | \")\n    }\n    return JSON.stringify(schema, null, 2)\n  }\n}\n\nfunction indent(str: string, prefix: string, isFirstLine: boolean) {\n  if (isFirstLine) {\n    return prefix + str.replace(/\\n(?!$)/g, \"\\n\" + prefix)\n  }\n  else {\n    return str.replace(/\\n(?!$)/g, `\\n${prefix}`)\n  }\n}\n\nfunction filterErrors(errors: Array<ErrorObject>) {\n  let newErrors: Array<any> = []\n  for (const error of errors) {\n    const dataPath = error.dataPath\n    let children: Array<ErrorObject> = []\n    newErrors = newErrors.filter(oldError => {\n      if (!oldError.dataPath.includes(dataPath)) {\n        return true\n      }\n\n      if (oldError.children != null) {\n        children = children.concat(oldError.children.slice(0))\n      }\n      oldError.children = null\n      children.push(oldError)\n      return false\n    })\n\n    if (children.length > 0) {\n      (error as any).children = children\n    }\n    newErrors.push(error)\n  }\n  return newErrors\n}"],"sourceRoot":""}
