"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash.zip"));

var _lodash2 = _interopRequireDefault(require("lodash.clonedeep"));

var _utils = require("@wdio/utils");

var _middlewares = require("./middlewares");

var _utils2 = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class MultiRemote {
  constructor() {
    this.instances = {};
  }

  async addInstance(browserName, client) {
    this.instances[browserName] = await client;
    return this.instances[browserName];
  }

  modifier(wrapperClient) {
    const propertiesObject = {};
    propertiesObject.commandList = {
      value: wrapperClient.commandList
    };
    propertiesObject.options = {
      value: wrapperClient.options
    };

    for (const commandName of wrapperClient.commandList) {
      propertiesObject[commandName] = {
        value: this.commandWrapper(commandName),
        configurable: true
      };
    }

    propertiesObject['__propertiesObject__'] = {
      value: propertiesObject
    };
    this.baseInstance = new MultiRemoteDriver(this.instances, propertiesObject);
    const client = Object.create(this.baseInstance, propertiesObject);

    for (const [identifier, instance] of Object.entries(this.instances)) {
      client[identifier] = instance;
    }

    return client;
  }

  static elementWrapper(instances, result, propertiesObject) {
    const prototype = _objectSpread({}, propertiesObject, {}, (0, _lodash2.default)((0, _utils2.getPrototype)('element')), {
      scope: 'element'
    });

    const element = (0, _utils.webdriverMonad)({}, client => {
      for (const [i, identifier] of Object.entries(Object.keys(instances))) {
        client[identifier] = result[i];
      }

      client.instances = Object.keys(instances);
      delete client.sessionId;
      return client;
    }, prototype);
    return element(this.sessionId, (0, _middlewares.multiremoteHandler)(_utils.wrapCommand));
  }

  commandWrapper(commandName) {
    const instances = this.instances;
    return (0, _utils.wrapCommand)(commandName, async function (...args) {
      const result = await Promise.all(Object.entries(instances).map(([, instance]) => instance[commandName](...args)));

      if (commandName === '$') {
        return MultiRemote.elementWrapper(instances, result, this.__propertiesObject__);
      } else if (commandName === '$$') {
        const zippedResult = (0, _lodash.default)(...result);
        return zippedResult.map(singleResult => MultiRemote.elementWrapper(instances, singleResult, this.__propertiesObject__));
      }

      return result;
    });
  }

}

exports.default = MultiRemote;

class MultiRemoteDriver {
  constructor(instances, propertiesObject) {
    this.instances = Object.keys(instances);
    this.isMultiremote = true;
    this.__propertiesObject__ = propertiesObject;
  }

  on(...args) {
    this.instances.forEach(instanceName => this[instanceName].on(...args));
  }

  once(...args) {
    this.instances.forEach(instanceName => this[instanceName].once(...args));
  }

  emit(...args) {
    this.instances.forEach(instanceName => this[instanceName].emit(...args));
  }

  eventNames(...args) {
    this.instances.forEach(instanceName => this[instanceName].eventNames(...args));
  }

  getMaxListeners() {
    this.instances.forEach(instanceName => this[instanceName].getMaxListeners());
  }

  listenerCount(...args) {
    this.instances.forEach(instanceName => this[instanceName].listenerCount(...args));
  }

  listeners(...args) {
    this.instances.forEach(instanceName => this[instanceName].listeners(...args));
  }

  removeListener(...args) {
    this.instances.forEach(instanceName => this[instanceName].removeListener(...args));
  }

  removeAllListeners(...args) {
    this.instances.forEach(instanceName => this[instanceName].removeAllListeners(...args));
  }

}