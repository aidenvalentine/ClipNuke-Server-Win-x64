{"version":3,"sources":["../../src/util/cacheManager.ts"],"names":[],"mappings":"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","sourcesContent":["import BluebirdPromise from \"bluebird-lst\"\nimport { Arch, log } from \"builder-util\"\nimport { copyFile } from \"builder-util/out/fs\"\nimport { orNullIfFileNotExist } from \"builder-util/out/promise\"\nimport { Hash } from \"crypto\"\nimport { ensureDir, readFile, readJson, writeJson } from \"fs-extra-p\"\nimport * as path from \"path\"\n\nexport interface BuildCacheInfo {\n  executableDigest: string\n}\n\nexport class BuildCacheManager {\n  static VERSION: string = \"0\"\n\n  readonly cacheDir: string\n  readonly cacheInfoFile: string\n  readonly cacheFile: string\n\n  cacheInfo: BuildCacheInfo | null = null\n\n  private newDigest: string | null = null\n\n  constructor(outDir: string, private readonly executableFile: string, arch: Arch) {\n    this.cacheDir = path.join(outDir, \".cache\", Arch[arch])\n    this.cacheFile = path.join(this.cacheDir, \"app.exe\")\n    this.cacheInfoFile = path.join(this.cacheDir, \"info.json\")\n  }\n\n  async copyIfValid(digest: string): Promise<boolean> {\n    this.newDigest = digest\n\n    this.cacheInfo = await orNullIfFileNotExist(readJson(this.cacheInfoFile))\n    const oldDigest = this.cacheInfo == null ? null : this.cacheInfo.executableDigest\n    if (oldDigest !== digest) {\n      log.debug({oldDigest, newDigest: digest}, \"no valid cached executable found\")\n      return false\n    }\n\n    log.debug({cacheFile: this.cacheFile, file: this.executableFile}, `copying cached executable`)\n    try {\n      await copyFile(this.cacheFile, this.executableFile, false)\n      return true\n    }\n    catch (e) {\n      if (e.code === \"ENOENT\" || e.code === \"ENOTDIR\") {\n        log.debug({error: e.code}, \"copy cached executable failed\")\n      }\n      else {\n        log.warn({error: e.stack || e}, `cannot copy cached executable`)\n      }\n    }\n    return false\n  }\n\n  async save() {\n    if (this.newDigest == null) {\n      throw new Error(\"call copyIfValid before\")\n    }\n\n    if (this.cacheInfo == null) {\n      this.cacheInfo = {executableDigest: this.newDigest}\n    }\n    else {\n      this.cacheInfo.executableDigest = this.newDigest\n    }\n\n    try {\n      await ensureDir(this.cacheDir)\n      await Promise.all([writeJson(this.cacheInfoFile, this.cacheInfo), copyFile(this.executableFile, this.cacheFile, false)])\n    }\n    catch (e) {\n      log.warn({error: e.stack || e}, `cannot save build cache`)\n    }\n  }\n}\n\nexport async function digest(hash: Hash, files: Array<string>) {\n  // do not use pipe - better do bulk file read (https://github.com/yarnpkg/yarn/commit/7a63e0d23c46a4564bc06645caf8a59690f04d01)\n  for (const content of await BluebirdPromise.map(files, it => readFile(it))) {\n    hash.update(content)\n  }\n\n  hash.update(BuildCacheManager.VERSION)\n  return hash.digest(\"base64\")\n}"],"sourceRoot":""}
