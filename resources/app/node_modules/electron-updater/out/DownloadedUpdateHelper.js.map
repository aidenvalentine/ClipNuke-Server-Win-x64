{"version":3,"sources":["../src/DownloadedUpdateHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { UpdateInfo } from \"builder-util-runtime\"\nimport { createHash } from \"crypto\"\nimport { createReadStream } from \"fs\"\nimport isEqual from \"lodash.isequal\"\nimport { Logger, ResolvedUpdateFileInfo } from \"./main\"\nimport { pathExists, readJson, emptyDir, outputJson, unlink } from \"fs-extra-p\"\nimport * as path from \"path\"\n\n/** @private **/\nexport class DownloadedUpdateHelper {\n  private _file: string | null = null\n  private _packageFile: string | null = null\n\n  private versionInfo: UpdateInfo | null = null\n  private fileInfo: ResolvedUpdateFileInfo | null = null\n\n  constructor(readonly cacheDir: string) {\n  }\n\n  private _downloadedFileInfo: CachedUpdateInfo | null = null\n  get downloadedFileInfo() {\n    return this._downloadedFileInfo\n  }\n\n  get file() {\n    return this._file\n  }\n\n  get packageFile() {\n    return this._packageFile\n  }\n\n  get cacheDirForPendingUpdate(): string {\n    return path.join(this.cacheDir, \"pending\")\n  }\n\n  async validateDownloadedPath(updateFile: string, updateInfo: UpdateInfo, fileInfo: ResolvedUpdateFileInfo, logger: Logger): Promise<string | null> {\n    if (this.versionInfo != null && this.file === updateFile && this.fileInfo != null) {\n      // update has already been downloaded from this running instance\n      // check here only existence, not checksum\n      if (isEqual(this.versionInfo, updateInfo) && isEqual(this.fileInfo.info, fileInfo.info) && (await pathExists(updateFile))) {\n        return updateFile\n      }\n      else {\n        return null\n      }\n    }\n\n    // update has already been downloaded from some previous app launch\n    const cachedUpdateFile = await this.getValidCachedUpdateFile(fileInfo, logger)\n    if (cachedUpdateFile == null) {\n      return null\n    }\n    logger.info(`Update has already been downloaded to ${updateFile}).`)\n    this._file = cachedUpdateFile\n    return cachedUpdateFile\n  }\n\n  async setDownloadedFile(downloadedFile: string, packageFile: string | null, versionInfo: UpdateInfo, fileInfo: ResolvedUpdateFileInfo, updateFileName: string, isSaveCache: boolean) {\n    this._file = downloadedFile\n    this._packageFile = packageFile\n    this.versionInfo = versionInfo\n    this.fileInfo = fileInfo\n    this._downloadedFileInfo = {\n      fileName: updateFileName,\n      sha512: fileInfo.info.sha512,\n      isAdminRightsRequired: fileInfo.info.isAdminRightsRequired === true,\n    }\n\n    if (isSaveCache) {\n      await outputJson(this.getUpdateInfoFile(), this._downloadedFileInfo)\n    }\n  }\n\n  async clear() {\n    this._file = null\n    this._packageFile = null\n    this.versionInfo = null\n    this.fileInfo = null\n    await this.cleanCacheDirForPendingUpdate()\n  }\n\n  private async cleanCacheDirForPendingUpdate(): Promise<void> {\n    try {\n      // remove stale data\n      await emptyDir(this.cacheDirForPendingUpdate)\n    }\n    catch (ignore) {\n      // ignore\n    }\n  }\n\n  private async getValidCachedUpdateFile(fileInfo: ResolvedUpdateFileInfo, logger: Logger): Promise<string | null> {\n    let cachedInfo: CachedUpdateInfo\n    const updateInfoFile = this.getUpdateInfoFile()\n    try {\n      cachedInfo = await readJson(updateInfoFile)\n    }\n    catch (e) {\n      let message = `No cached update info available`\n      if (e.code !== \"ENOENT\") {\n        await this.cleanCacheDirForPendingUpdate()\n        message += ` (error on read: ${e.message})`\n      }\n      logger.info(message)\n      return null\n    }\n\n    if (cachedInfo.fileName == null) {\n      logger.warn(`Cached update info is corrupted: no fileName, directory for cached update will be cleaned`)\n      await this.cleanCacheDirForPendingUpdate()\n      return null\n    }\n\n    if (fileInfo.info.sha512 !== cachedInfo.sha512) {\n      logger.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${cachedInfo.sha512}, expected: ${fileInfo.info.sha512}. Directory for cached update will be cleaned`)\n      await this.cleanCacheDirForPendingUpdate()\n      return null\n    }\n\n    const updateFile = path.join(this.cacheDirForPendingUpdate, cachedInfo.fileName)\n    if (!(await pathExists(updateFile))) {\n      logger.info(\"Cached update file doesn't exist, directory for cached update will be cleaned\")\n      await this.cleanCacheDirForPendingUpdate()\n      return null\n    }\n\n    const sha512 = await hashFile(updateFile)\n    if (fileInfo.info.sha512 !== sha512) {\n      logger.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${sha512}, expected: ${fileInfo.info.sha512}`)\n      await this.cleanCacheDirForPendingUpdate()\n      return null\n    }\n    this._downloadedFileInfo = cachedInfo\n    return updateFile\n  }\n\n  private getUpdateInfoFile() {\n    return path.join(this.cacheDirForPendingUpdate, \"update-info.json\")\n  }\n}\n\ninterface CachedUpdateInfo {\n  fileName: string\n  sha512: string\n  readonly isAdminRightsRequired: boolean\n}\n\nfunction hashFile(file: string, algorithm: string = \"sha512\", encoding: \"base64\" | \"hex\" = \"base64\", options?: any) {\n  return new Promise<string>((resolve, reject) => {\n    const hash = createHash(algorithm)\n    hash\n      .on(\"error\", reject)\n      .setEncoding(encoding)\n\n    createReadStream(file, {...options, highWaterMark: 1024 * 1024 /* better to use more memory but hash faster */})\n      .on(\"error\", reject)\n      .on(\"end\", () => {\n        hash.end()\n        resolve(hash.read() as string)\n      })\n      .pipe(hash, {end: false})\n  })\n}\n\nexport async function createTempUpdateFile(name: string, cacheDir: string, log: Logger) {\n  // https://github.com/electron-userland/electron-builder/pull/2474#issuecomment-366481912\n  let nameCounter = 0\n  let result = path.join(cacheDir, name)\n  for (let i = 0; i < 3; i++) {\n    try {\n      await unlink(result)\n      return result\n    }\n    catch (e) {\n      if (e.code === \"ENOENT\") {\n        return result\n      }\n\n      log.warn(`Error on remove temp update file: ${e}`)\n      result = path.join(cacheDir, `${nameCounter++}-${name}`)\n    }\n  }\n  return result\n}"],"sourceRoot":""}
