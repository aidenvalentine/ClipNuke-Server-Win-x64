{"version":3,"sources":["../src/electronHttpExecutor.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAMO,MAAM,gBAAgB,GAAG,kBAAzB;;;AAED,SAAU,aAAV,GAAuB;AAC3B,SAAO,oBAAQ,aAAR,CAAsB,gBAAtB,EAAwC;AAC7C,IAAA,KAAK,EAAE;AADsC,GAAxC,CAAP;AAGD;;AAEK,MAAO,oBAAP,SAAoC,kCAApC,CAAwE;AAG5E,EAAA,WAAA,CAA6B,kBAA7B,EAAkG;AAChG;AAD2B,SAAA,kBAAA,GAAA,kBAAA;AAFrB,SAAA,aAAA,GAAgC,IAAhC;AAIP;;AAEK,EAAA,QAAN,CAAe,GAAf,EAAyB,WAAzB,EAA8C,OAA9C,EAAsE;AAAA;;AAAA;AACpE,mBAAa,OAAO,CAAC,iBAAR,CAA0B,aAA1B,CAAgD,CAAC,OAAD,EAAU,MAAV,EAAkB,QAAlB,KAA8B;AACzF,cAAM,cAAc,GAAG;AACrB,UAAA,OAAO,EAAE,OAAO,CAAC,OAAR,IAAmB,SADP;AAErB,UAAA,QAAQ,EAAE;AAFW,SAAvB;AAIA,uDAAoB,GAApB,EAAyB,cAAzB;AACA,2DAAwB,cAAxB;;AACA,QAAA,KAAI,CAAC,UAAL,CAAgB,cAAhB,EAAgC;AAC9B,UAAA,WAD8B;AAE9B,UAAA,OAF8B;AAG9B,UAAA,QAH8B;AAI9B,UAAA,QAAQ,EAAE,KAAK,IAAG;AAChB,gBAAI,KAAK,IAAI,IAAb,EAAmB;AACjB,cAAA,OAAO,CAAC,WAAD,CAAP;AACD,aAFD,MAGK;AACH,cAAA,MAAM,CAAC,KAAD,CAAN;AACD;AACF,WAX6B;AAY9B,UAAA,eAAe,EAAE;AAZa,SAAhC,EAaG,CAbH;AAcD,OArBY,CAAb;AADoE;AAuBrE;;AAED,EAAA,aAAa,CAAC,OAAD,EAAe,QAAf,EAAgD;AAC3D;AACA,QAAI,KAAK,aAAL,IAAsB,IAA1B,EAAgC;AAC9B,WAAK,aAAL,GAAqB,aAAa,EAAlC;AACD;;AAED,UAAM,OAAO,GAAG,gBAAI,OAAJ,CAAW,MAAA,CAAA,MAAA,CAAA,EAAA,EACtB,OADsB,EACf;AACV,MAAA,OAAO,EAAE,KAAK;AADJ,KADe,CAAX,CAAhB;;AAIA,IAAA,OAAO,CAAC,EAAR,CAAW,UAAX,EAAuB,QAAvB;;AACA,QAAI,KAAK,kBAAL,IAA2B,IAA/B,EAAqC;AACnC,MAAA,OAAO,CAAC,EAAR,CAAW,OAAX,EAAoB,KAAK,kBAAzB;AACD;;AACD,WAAO,OAAP;AACD;;AACS,EAAA,mBAAmB,CAAC,OAAD,EAAyB,OAAzB,EAAkD,MAAlD,EAAkF,aAAlF,EAAyG,OAAzG,EAAmJ;AAC9K,IAAA,OAAO,CAAC,EAAR,CAAW,UAAX,EAAuB,CAAC,UAAD,EAAqB,MAArB,EAAqC,WAArC,KAA4D;AACjF;AACA;AACA,MAAA,OAAO,CAAC,KAAR;;AAEA,UAAI,aAAa,GAAG,KAAK,YAAzB,EAAuC;AACrC,QAAA,MAAM,CAAC,KAAK,sBAAL,EAAD,CAAN;AACD,OAFD,MAGK;AACH,QAAA,OAAO,CAAC,mCAAa,yBAAb,CAAuC,WAAvC,EAAoD,OAApD,CAAD,CAAP;AACD;AACF,KAXD;AAYD;;AA7D2E,C","sourcesContent":["import { DownloadOptions, HttpExecutor, configureRequestOptions, configureRequestUrl } from \"builder-util-runtime\"\nimport { net, session } from \"electron\"\nimport { RequestOptions } from \"http\"\nimport Session = Electron.Session\nimport ClientRequest = Electron.ClientRequest\n\nexport type LoginCallback = (username: string, password: string) => void\nexport const NET_SESSION_NAME = \"electron-updater\"\n\nexport function getNetSession(): Session {\n  return session.fromPartition(NET_SESSION_NAME, {\n    cache: false\n  })\n}\n\nexport class ElectronHttpExecutor extends HttpExecutor<Electron.ClientRequest> {\n  private cachedSession: Session | null = null\n\n  constructor(private readonly proxyLoginCallback?: (authInfo: any, callback: LoginCallback) => void) {\n    super()\n  }\n\n  async download(url: URL, destination: string, options: DownloadOptions): Promise<string> {\n    return await options.cancellationToken.createPromise<string>((resolve, reject, onCancel) => {\n      const requestOptions = {\n        headers: options.headers || undefined,\n        redirect: \"manual\",\n      }\n      configureRequestUrl(url, requestOptions)\n      configureRequestOptions(requestOptions)\n      this.doDownload(requestOptions, {\n        destination,\n        options,\n        onCancel,\n        callback: error => {\n          if (error == null) {\n            resolve(destination)\n          }\n          else {\n            reject(error)\n          }\n        },\n        responseHandler: null,\n      }, 0)\n    })\n  }\n\n  createRequest(options: any, callback: (response: any) => void): any {\n    // differential downloader can call this method very often, so, better to cache session\n    if (this.cachedSession == null) {\n      this.cachedSession = getNetSession()\n    }\n\n    const request = net.request({\n      ...options,\n      session: this.cachedSession,\n    })\n    request.on(\"response\", callback)\n    if (this.proxyLoginCallback != null) {\n      request.on(\"login\", this.proxyLoginCallback)\n    }\n    return request\n  }\n  protected addRedirectHandlers(request: ClientRequest, options: RequestOptions, reject: (error: Error) => void, redirectCount: number, handler: (options: RequestOptions) => void) {\n    request.on(\"redirect\", (statusCode: number, method: string, redirectUrl: string) => {\n      // no way to modify request options, abort old and make a new one\n      // https://github.com/electron/electron/issues/11505\n      request.abort()\n\n      if (redirectCount > this.maxRedirects) {\n        reject(this.createMaxRedirectError())\n      }\n      else {\n        handler(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options))\n      }\n    })\n  }\n}"],"sourceRoot":""}
